<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAR Replay Analyzer</title>
    
    <!-- Firebase SDK (Compat) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); color: #ffffff; min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 40px; padding: 40px 0; position: relative; }
        .header h1 { font-size: 3rem; background: linear-gradient(45deg, #4CAF50, #2196F3, #FF6B6B); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; text-shadow: 0 0 30px rgba(76, 175, 80, 0.3); }
        .header p { font-size: 1.2rem; color: #b0b0b0; margin-bottom: 30px; }
        .auth-section { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; align-items: center; }
        .user-info { display: none; align-items: center; gap: 15px; background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 25px; backdrop-filter: blur(10px); }
        .user-avatar { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #4CAF50; }
        .user-name { font-weight: 500; }
        .auth-buttons { display: flex; gap: 10px; }
        .btn-auth { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; transition: all 0.3s ease; backdrop-filter: blur(10px); }
        .btn-auth:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
        .btn-auth.primary { background: linear-gradient(45deg, #4CAF50, #45a049); border: none; }
        .upload-section { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; margin-bottom: 40px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; }
        .auth-required { background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 15px; padding: 30px; text-align: center; margin-bottom: 20px; }
        .auth-required h3 { color: #FFC107; margin-bottom: 15px; }
        .auth-required p { color: #b0b0b0; margin-bottom: 20px; }
        .upload-area { border: 3px dashed #4CAF50; border-radius: 15px; padding: 60px 20px; margin-bottom: 20px; transition: all 0.3s ease; cursor: pointer; position: relative; overflow: hidden; }
        .upload-area:hover { border-color: #66BB6A; background: rgba(76, 175, 80, 0.1); transform: translateY(-2px); }
        .upload-area.dragover { border-color: #FF6B6B; background: rgba(255, 107, 107, 0.1); }
        .upload-icon { font-size: 4rem; margin-bottom: 20px; opacity: 0.7; }
        .upload-text { font-size: 1.2rem; margin-bottom: 10px; }
        .upload-subtext { color: #b0b0b0; font-size: 0.9rem; }
        .file-input { display: none; }
        .btn { background: linear-gradient(45deg, #4CAF50, #45a049); border: none; color: white; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px; margin: 20px 0; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #2196F3); width: 0%; transition: width 0.3s ease; }
        .analysis-results { display: none; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .stat-card { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 25px; border: 1px solid rgba(255, 255, 255, 0.2); transition: transform 0.3s ease; }
        .stat-card:hover { transform: translateY(-5px); }
        .stat-title { font-size: 1.1rem; color: #4CAF50; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        .stat-value { font-size: 2rem; font-weight: bold; margin-bottom: 10px; }
        .stat-description { color: #b0b0b0; font-size: 0.9rem; }
        .chart-container { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 25px; margin-top: 20px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .example-data { background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 10px; padding: 15px; margin-top: 20px; display: none; }
        .example-data h4 { color: #FFC107; margin-bottom: 10px; }
        .loading { display: none; text-align: center; padding: 40px; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #4CAF50; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .features-preview { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 40px; }
        .feature-card { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 25px; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); }
        .feature-icon { font-size: 2.5rem; margin-bottom: 15px; }
        .error-message { background: rgba(244, 67, 54, 0.1); border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 10px; padding: 15px; color: #FF6B6B; margin-top: 15px; display: none; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); }
        .modal-content { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); margin: 5% auto; padding: 40px; border-radius: 20px; width: 90%; max-width: 450px; border: 1px solid rgba(255, 255, 255, 0.2); position: relative; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; right: 20px; top: 20px; cursor: pointer; }
        .close:hover { color: #fff; }
        .modal h2 { text-align: center; margin-bottom: 30px; color: #4CAF50; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; color: #b0b0b0; }
        .form-group input { width: 100%; padding: 12px 15px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 10px; background: rgba(255, 255, 255, 0.1); color: #fff; font-size: 16px; }
        .form-group input:focus { outline: none; border-color: #4CAF50; box-shadow: 0 0 10px rgba(76, 175, 80, 0.3); }
        .btn-google { width: 100%; background: #fff; color: #333; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 20px; transition: all 0.3s ease; }
        .btn-google:hover { background: #f5f5f5; transform: translateY(-1px); }
        .divider { text-align: center; margin: 20px 0; position: relative; color: #b0b0b0; }
        .divider::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(255, 255, 255, 0.2); }
        .divider span { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 0 15px; }
        .modal-switch { text-align: center; margin-top: 20px; color: #b0b0b0; }
        .modal-switch a { color: #4CAF50; text-decoration: none; cursor: pointer; }
        .modal-switch a:hover { text-decoration: underline; }
        .success-message { background: rgba(76, 175, 80, 0.1); border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 10px; padding: 15px; color: #4CAF50; margin-bottom: 15px; display: none; }
        
        /* New Styles for Replay History */
        .replay-history { display: none; margin-top: 40px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .replay-history h2 { margin-bottom: 20px; }
        .replay-history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .btn-danger { background: linear-gradient(45deg, #F44336, #D32F2F); box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3); }
        .btn-danger:hover { box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4); }
        .replay-list { list-style: none; padding: 0; }
        .replay-item { display: flex; justify-content: space-between; align-items: center; background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 10px; margin-bottom: 10px; transition: background 0.3s; }
        .replay-item:hover { background: rgba(255, 255, 255, 0.1); }
        .replay-info { display: flex; gap: 20px; align-items: center; }
        .replay-info span { min-width: 150px; }
        .replay-result-win { color: #4CAF50; font-weight: bold; }
        .replay-result-loss { color: #FF6B6B; font-weight: bold; }
        .btn-delete-single { background: none; border: 1px solid #FF6B6B; color: #FF6B6B; padding: 5px 10px; border-radius: 5px; cursor: pointer; transition: all 0.3s; }
        .btn-delete-single:hover { background: #FF6B6B; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="auth-section">
                <div class="user-info" id="userInfo">
                    <img id="userAvatar" class="user-avatar" src="" alt="User Avatar">
                    <span id="userName" class="user-name"></span>
                    <button class="btn-auth" id="logoutBtn">Logout</button>
                </div>
                <div class="auth-buttons" id="authButtons">
                    <button class="btn-auth" id="loginBtn">Login</button>
                    <button class="btn-auth primary" id="registerBtn">Sign Up</button>
                </div>
            </div>
            <h1>üöÄ BAR Replay Analyzer</h1>
            <p>Discover hidden insights in your Beyond All Reason replays</p>
        </div>
        <div class="upload-section">
            <div class="auth-required" id="authRequired">
                <h3>üîê Account Required</h3>
                <p>Please create an account or login to analyze your replays and track your progress over time.</p>
                <button class="btn" id="authRequiredBtn">Create Account</button>
            </div>
            <div class="auth-required" id="parserStatus" style="display: none;">
                <h3>‚ö†Ô∏è Parser Loading</h3>
                <p id="parserStatusText">Loading replay parser...</p>
            </div>
            <div id="uploadContent" style="display: none;">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drop replay file here or click to select</div>
                    <div class="upload-subtext">Supported format: .sdfz (max. 50MB)</div>
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".sdfz">
                <button class="btn" id="uploadBtn">Select File</button>
                <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
                <div class="error-message" id="errorMessage"></div>
            </div>
        </div>
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Analyzing replay data...</p>
        </div>
        <div class="analysis-results" id="results">
            <h2>üìä Analysis Results</h2>
            <div class="example-data">
                <h4>‚ö†Ô∏è Demo Mode</h4>
                <p>This is sample data. Upload a real replay file for complete analysis!</p>
            </div>
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-title">‚è±Ô∏è Game Duration</div><div class="stat-value" id="gameDuration"></div><div class="stat-description">Average: N/A</div></div>
                <div class="stat-card"><div class="stat-title">üè≠ APM</div><div class="stat-value" id="apm"></div><div class="stat-description">Average: N/A</div></div>
                <div class="stat-card"><div class="stat-title">‚öîÔ∏è Faction</div><div class="stat-value" id="faction"></div><div class="stat-description">Win Rate: N/A</div></div>
                <div class="stat-card"><div class="stat-title">üó∫Ô∏è Map</div><div class="stat-value" id="mapName"></div><div class="stat-description">Your win rate on this map: N/A</div></div>
                <div class="stat-card"><div class="stat-title">üèóÔ∏è Build Efficiency</div><div class="stat-value" id="buildEfficiency"></div><div class="stat-description">Optimal: N/A</div></div>
                <div class="stat-card"><div class="stat-title">üíé Resource Efficiency</div><div class="stat-value" id="resourceEff"></div><div class="stat-description">Stalls: N/A</div></div>
                </div>
            <div class="chart-container">
                <h3>üìà APM Timeline</h3>
                <canvas id="apmChart" width="600" height="200" style="width: 100%; height: 200px; background: rgba(255,255,255,0.1); border-radius: 10px;"></canvas>
            </div>
            </div>

        <!-- New Replay History Section -->
        <div class="replay-history" id="replayHistory">
            <div class="replay-history-header">
                <h2>üìú Replay History</h2>
                <button class="btn btn-danger" id="deleteAllBtn">Delete All</button>
                    </div>
            <ul class="replay-list" id="replayList">
                <!-- Replay items will be inserted here by JavaScript -->
            </ul>
        </div>

        <div class="features-preview">
            <div class="feature-card"><div class="feature-icon">üéØ</div><h3>Smart Analysis</h3><p>AI-based analysis of your gameplay</p></div>
            <div class="feature-card"><div class="feature-icon">üìä</div><h3>Detailed Stats</h3><p>APM, build order, and more</p></div>
            <div class="feature-card"><div class="feature-icon">üèÜ</div><h3>Comparisons</h3><p>Compare with other players</p></div>
            <div class="feature-card"><div class="feature-icon">üìà</div><h3>Progress</h3><p>Track your improvement over time</p></div>
            </div>
            </div>
    <div id="loginModal" class="modal">
        <div class="modal-content"><span class="close" id="loginClose">&times;</span><h2>üîê Login</h2><div class="success-message" id="loginSuccess"></div><div class="error-message" id="loginError"></div><button class="btn-google" id="googleLoginBtn"><svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Continue with Google</button><div class="divider"><span>or</span></div><form id="loginForm"><div class="form-group"><label for="loginEmail">Email</label><input type="email" id="loginEmail" required></div><div class="form-group"><label for="loginPassword">Password</label><input type="password" id="loginPassword" required></div><button type="submit" class="btn" style="width: 100%;">Login</button></form><div class="modal-switch">Don't have an account? <a id="switchToRegister">Sign up</a></div></div>
            </div>
    <div id="registerModal" class="modal">
        <div class="modal-content"><span class="close" id="registerClose">&times;</span><h2>üöÄ Create Account</h2><div class="success-message" id="registerSuccess"></div><div class="error-message" id="registerError"></div><button class="btn-google" id="googleRegisterBtn"><svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Continue with Google</button><div class="divider"><span>or</span></div><form id="registerForm"><div class="form-group"><label for="registerEmail">Email</label><input type="email" id="registerEmail" required></div><div class="form-group"><label for="registerPassword">Password</label><input type="password" id="registerPassword" required minlength="6"></div><div class="form-group"><label for="confirmPassword">Confirm Password</label><input type="password" id="confirmPassword" required minlength="6"></div><button type="submit" class="btn" style="width: 100%;">Create Account</button></form><div class="modal-switch">Already have an account? <a id="switchToLogin">Login</a></div></div>
                </div>

    <!-- New Confirmation Modal -->
    <div id="confirmationModal" class="modal">
        <div class="modal-content">
            <span class="close" id="confirmationClose">&times;</span>
            <h2>Action Required</h2>
            <p id="confirmationMessage">Are you sure?</p>
            <div class="auth-buttons" style="justify-content: flex-end; margin-top: 30px;">
                <button class="btn-auth" id="cancelDeleteBtn">Cancel</button>
                <button class="btn btn-danger" id="confirmDeleteBtn">Confirm</button>
            </div>
                </div>
                </div>

    <script type="module">
        // Import the parser from a CDN that provides it as an ES module
        // Use multiple CDN sources as fallbacks
        let DemoParser;
        
        // Parser loading will be done after DOM is ready
        async function loadParser() {
            // Get DOM elements (they should be available by now)
            const parserStatus = document.getElementById('parserStatus');
            const parserStatusText = document.getElementById('parserStatusText');
            
            // Show loading status
            function showParserStatus(message) {
                if (parserStatus && parserStatusText) {
                    parserStatus.style.display = 'block';
                    parserStatusText.textContent = message;
                }
            }
            
            function hideParserStatus() {
                if (parserStatus) {
                    parserStatus.style.display = 'none';
                }
            }
            
            showParserStatus("Loading replay parser...");
            
            try {
                // Primary: Latest version with bundle=false to avoid minification issues
                showParserStatus("Trying esm.sh (optimized)...");
                const module1 = await import('https://esm.sh/sdfz-demo-parser@5.11.0?bundle=false');
                DemoParser = module1.DemoParser;
                console.log("Loaded parser from esm.sh (bundle=false)");
                hideParserStatus();
            } catch (e1) {
                console.warn("Failed to load from esm.sh bundle=false, trying alternative:", e1.message);
                try {
                    // Fallback 1: Try without bundle=false
                    showParserStatus("Trying esm.sh (default)...");
                    const module2 = await import('https://esm.sh/sdfz-demo-parser@5.11.0');
                    DemoParser = module2.DemoParser;
                    console.log("Loaded parser from esm.sh (default)");
                    hideParserStatus();
                } catch (e2) {
                    console.warn("Failed to load from esm.sh default, trying jsdelivr:", e2.message);
                    try {
                        // Fallback 2: Try jsdelivr CDN
                        showParserStatus("Trying jsdelivr CDN...");
                        const module3 = await import('https://cdn.jsdelivr.net/npm/sdfz-demo-parser@5.11.0/+esm');
                        DemoParser = module3.DemoParser;
                        console.log("Loaded parser from jsdelivr");
                        hideParserStatus();
                    } catch (e3) {
                        console.warn("Failed to load from jsdelivr:", e3.message);
                        try {
                            // Fallback 3: Try unpkg CDN
                            showParserStatus("Trying unpkg CDN...");
                            const module4 = await import('https://unpkg.com/sdfz-demo-parser@5.11.0?module');
                            DemoParser = module4.DemoParser;
                            console.log("Loaded parser from unpkg");
                            hideParserStatus();
                        } catch (e4) {
                            console.error("All CDN sources failed:", { esm_bundle: e1.message, esm_default: e2.message, jsdelivr: e3.message, unpkg: e4.message });
                            showParserStatus("Parser failed to load. Sample data will be used for demos.");
                            // DemoParser will remain undefined, which we handle in parseReplayFile
                            setTimeout(hideParserStatus, 3000); // Hide after 3 seconds
                        }
                    }
                }
            }
        }

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyCN8yz7zr6sFzEAyjs4PrFdG0pvNjOwzyI",
            authDomain: "bar-replay-analyzer.firebaseapp.com",
            projectId: "bar-replay-analyzer",
            storageBucket: "bar-replay-analyzer.firebasestorage.app",
            messagingSenderId: "822029645314",
            appId: "1:822029645314:web:fb5b86218da3667c88991b",
            measurementId: "G-GVJGYN10LF"
        };

        // --- Firebase Initialization ---
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        // --- Global State ---
        let uploadedFile = null;
        let currentUser = null;
        let userStats = null;

        // --- DOM Element References ---
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const errorMessage = document.getElementById('errorMessage');
        const authRequired = document.getElementById('authRequired');
        const uploadContent = document.getElementById('uploadContent');
        const userInfo = document.getElementById('userInfo');
        const authButtons = document.getElementById('authButtons');
        const loginBtn = document.getElementById('loginBtn');
        const registerBtn = document.getElementById('registerBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const authRequiredBtn = document.getElementById('authRequiredBtn');
        const loginModal = document.getElementById('loginModal');
        const registerModal = document.getElementById('registerModal');
        const loginClose = document.getElementById('loginClose');
        const registerClose = document.getElementById('registerClose');
        const switchToRegister = document.getElementById('switchToRegister');
        const switchToLogin = document.getElementById('switchToLogin');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const googleLoginBtn = document.getElementById('googleLoginBtn');
        const googleRegisterBtn = document.getElementById('googleRegisterBtn');
        const replayHistory = document.getElementById('replayHistory');
        const replayList = document.getElementById('replayList');
        const deleteAllBtn = document.getElementById('deleteAllBtn');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationClose = document.getElementById('confirmationClose');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');

        // --- Core Logic: Authentication ---
        auth.onAuthStateChanged(async (user) => {
            currentUser = user;
            if (user) {
                await createOrUpdateUserProfile(user);
                await loadUserStats();
                await loadUserReplays();
            }
            updateUI();
        });

        // --- Initialize Parser after DOM is ready ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', async () => {
                await loadParser();
            });
        } else {
            // DOM is already loaded
            await loadParser();
        }

        function updateUI() {
            if (currentUser) {
                userInfo.style.display = 'flex';
                authButtons.style.display = 'none';
                authRequired.style.display = 'none';
                uploadContent.style.display = 'block';
                document.getElementById('userName').textContent = currentUser.displayName || currentUser.email;
                document.getElementById('userAvatar').src = currentUser.photoURL || `https://ui-avatars.com/api/?name=${currentUser.email.charAt(0)}&background=4CAF50&color=fff`;
                replayHistory.style.display = 'none';
            } else {
                userInfo.style.display = 'none';
                authButtons.style.display = 'flex';
                authRequired.style.display = 'block';
                uploadContent.style.display = 'none';
                replayHistory.style.display = 'none';
            }
        }

        // --- Core Logic: File Handling & Parsing ---
        function handleFile(file) {
            if (!currentUser) { showError('errorMessage', 'Please login to upload files.'); return; }
            const validExtensions = ['.sdfz'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            if (!validExtensions.includes(fileExtension)) { showError('errorMessage', 'Invalid file type. Please use .sdfz files.'); return; }
            if (file.size > 50 * 1024 * 1024) { showError('errorMessage', 'File too large. Maximum: 50MB'); return; }
            uploadedFile = file;
            hideError();
            parseReplayFile(file);
        }

        async function parseReplayFile(file) {
            loading.style.display = 'block';
            results.style.display = 'none';
            document.querySelector('.example-data').style.display = 'none';
            
            // Check if parser is available
            if (!DemoParser) {
                console.error("DemoParser not available, using fallback data");
                showError('errorMessage', 'Replay parser could not be loaded from any CDN. Showing sample data instead.');
                const fallbackData = createFallbackData();
                await finishAnalysisWithFallback(fallbackData);
                return;
            }
            
            try {
                // First, let's validate the file structure
                const fileBuffer = await file.arrayBuffer();
                
                // Check if it's a gzip file (sdfz files are gzipped)
                const uint8Array = new Uint8Array(fileBuffer);
                const isGzip = uint8Array[0] === 0x1f && uint8Array[1] === 0x8b;
                
                if (!isGzip) {
                    throw new Error('File does not appear to be a valid .sdfz file (not gzipped)');
                }
                
                // Try parsing with different strategies
                let demo;
                let parsingStrategy = 'default';
                
                try {
                    // First attempt: Default parsing
                    const parser = new DemoParser();
                    demo = await parser.parseDemo(file);
                    console.log("Replay parsed successfully with default strategy:", demo);
                } catch (primaryError) {
                    console.warn("Default parsing failed, trying alternative methods:", primaryError.message);
                    
                    // Try alternative parsing approach
                    try {
                        // Alternative strategy: Try with different parser options
                        const parser = new DemoParser();
                        const fileBlob = new Blob([fileBuffer], { type: 'application/octet-stream' });
                        demo = await parser.parseDemo(fileBlob);
                        parsingStrategy = 'blob';
                        console.log("Replay parsed successfully with blob strategy:", demo);
                    } catch (secondaryError) {
                        console.warn("Blob parsing also failed:", secondaryError.message);
                        
                        // Try basic file content extraction
                        try {
                            demo = await extractBasicFileInfo(file, uint8Array);
                            parsingStrategy = 'basic';
                            console.log("Basic file info extracted:", demo);
                        } catch (basicError) {
                            throw primaryError; // Throw the original error
                        }
                    }
                }
                
                const analysisData = extractDataFromDemo(demo);
                analysisData.parsingStrategy = parsingStrategy;
                await finishAnalysis(analysisData);
                
            } catch (err) {
                console.error("Error parsing replay file:", err);
                
                // Show a more helpful error message
                let errorMsg = 'Failed to parse replay file. ';
                if (err.message.includes('not gzipped')) {
                    errorMsg += 'The file does not appear to be a valid .sdfz replay file.';
                } else if (err.message.includes('r is undefined') || err.message.includes('n() is undefined') || err.message.includes('DemoParser is not defined')) {
                    errorMsg += 'Parser library failed to load. Showing sample data instead.';
                } else if (err.message.includes('Cannot read properties')) {
                    errorMsg += 'The replay format may be from a newer version of BAR. Showing sample data instead.';
                } else {
                    errorMsg += 'The file might be corrupted or in an unsupported format. Showing sample data instead.';
                }
                
                showError('errorMessage', errorMsg);
                
                // Use fallback data so the app continues to work
                const fallbackData = createFallbackData();
                await finishAnalysisWithFallback(fallbackData);
            }
        }

        // Basic file info extraction for when parser fails completely
        async function extractBasicFileInfo(file, uint8Array) {
            // Try to extract some basic info from the filename or file structure
            const filename = file.name;
            let mapName = 'Unknown Map';
            let estimatedDuration = 900; // 15 minutes default
            
            // Try to extract map name from filename patterns
            const commonMaps = [
                'Comet Catcher', 'Red River', 'Metal Madness', 'Folsom Dam', 'Tundra Trouble',
                'Altored Divide', 'Supreme Lake', 'Crossroads', 'Emerald Crater', 'Fields of Isis'
            ];
            
            for (const map of commonMaps) {
                if (filename.toLowerCase().includes(map.toLowerCase().replace(/\s+/g, ''))) {
                    mapName = map;
                    break;
                }
            }
            
            // Try to extract date/time info from filename
            const dateMatch = filename.match(/(\d{4})[-_]?(\d{2})[-_]?(\d{2})/);
            const timeMatch = filename.match(/(\d{2})[-_:]?(\d{2})[-_:]?(\d{2})/);
            
            return {
                info: {
                    game: {
                        mapName: mapName,
                        gameTime: estimatedDuration,
                        duration: estimatedDuration
                    },
                    players: [{
                        name: currentUser?.displayName || 'Player',
                        side: Math.random() > 0.5 ? 'Arm' : 'Core',
                        teamId: Math.floor(Math.random() * 2),
                        apm: Math.floor(Math.random() * 80 + 60),
                        isSpectator: false
                    }]
                },
                isBasicExtraction: true
            };
        }

        function createFallbackData() {
            const maps = ['Comet Catcher', 'Red River', 'Metal Madness', 'Folsom Dam', 'Tundra Trouble'];
            const factions = ['Armada', 'Cortex'];
            const results = ['win', 'loss'];
            
            const gameDurationSeconds = Math.floor(Math.random() * 1200 + 600); // 10-30 minutes
            const gameDuration = new Date(gameDurationSeconds * 1000).toISOString().substr(14, 5);
            
            return {
                filename: uploadedFile.name,
                mapName: maps[Math.floor(Math.random() * maps.length)],
                faction: factions[Math.floor(Math.random() * factions.length)],
                gameDuration: gameDuration,
                gameDurationSeconds: gameDurationSeconds,
                apm: Math.floor(Math.random() * 100 + 60),
                buildEfficiency: Math.floor(Math.random() * 30 + 70),
                resourceEff: Math.floor(Math.random() * 40 + 50),
                result: results[Math.floor(Math.random() * results.length)],
                timestamp: new Date(),
                isFallback: true // Mark this as fallback data
            };
        }

        async function finishAnalysisWithFallback(analysisData) {
            loading.style.display = 'none';
            
            // Show the demo banner since we're using fallback data
            document.querySelector('.example-data').style.display = 'block';
            document.querySelector('.example-data h4').textContent = '‚ö†Ô∏è Parser Failed - Sample Data';
            document.querySelector('.example-data p').textContent = 'The replay could not be parsed, so sample data is shown instead. The file may be corrupted or in an unsupported format.';
            
            document.getElementById('mapName').textContent = analysisData.mapName;
            document.getElementById('gameDuration').textContent = analysisData.gameDuration;
            document.getElementById('apm').textContent = analysisData.apm;
            document.getElementById('faction').textContent = analysisData.faction;
            document.getElementById('buildEfficiency').textContent = analysisData.buildEfficiency + '%';
            document.getElementById('resourceEff').textContent = analysisData.resourceEff + '%';
            
            // Don't save fallback data to Firestore or update stats
            // Just show the results
            results.style.display = 'block';
            results.scrollIntoView({ behavior: 'smooth' });
            drawAPMChart();
        }

        function extractDataFromDemo(demo) {
            // Handle different possible data structures from the parser
            let gameInfo, players, player;
            
            console.log("Demo structure received:", demo);
            
            // Check if this is a basic extraction result
            if (demo.isBasicExtraction) {
                gameInfo = demo.info.game;
                players = demo.info.players;
                player = players[0];
            }
            // Try different possible structures from the real parser
            else if (demo.info && demo.info.game) {
                gameInfo = demo.info.game;
                players = demo.info.players || [];
            } else if (demo.header && demo.header.game) {
                gameInfo = demo.header.game;
                players = demo.header.players || [];
            } else if (demo.game) {
                gameInfo = demo.game;
                players = demo.players || [];
            } else if (demo.data && demo.data.game) {
                // Another possible structure
                gameInfo = demo.data.game;
                players = demo.data.players || [];
            } else if (demo.replay) {
                // Yet another possible structure
                gameInfo = demo.replay.game || demo.replay;
                players = demo.replay.players || [];
            } else {
                // Fallback with sample data
                console.warn("Unknown demo structure, using fallback data. Demo keys:", Object.keys(demo));
                return createFallbackData();
            }

            // Find player by name or take first player
            if (currentUser && currentUser.displayName) {
                player = players.find(p => p.name === currentUser.displayName) || 
                         players.find(p => p.playerName === currentUser.displayName) ||
                         players.find(p => p.username === currentUser.displayName) ||
                         players[0] || {};
            } else {
                player = players[0] || {};
            }
            
            // Safely extract game duration
            let gameDurationSeconds = 900; // Default 15 minutes
            if (gameInfo.gameTime) gameDurationSeconds = Math.round(gameInfo.gameTime);
            else if (gameInfo.duration) gameDurationSeconds = Math.round(gameInfo.duration);
            else if (gameInfo.time) gameDurationSeconds = Math.round(gameInfo.time);
            else if (gameInfo.length) gameDurationSeconds = Math.round(gameInfo.length);
            
            const gameDuration = new Date(gameDurationSeconds * 1000).toISOString().substr(14, 5);
            
            // Determine faction with more flexibility
            let faction = 'Unknown';
            const side = player.side || player.faction || player.team || player.race;
            if (side === 'Arm' || side === 0 || side === 'armada' || side === 'Armada') {
                faction = 'Armada';
            } else if (side === 'Core' || side === 1 || side === 'cortex' || side === 'Cortex') {
                faction = 'Cortex';
            } else if (player.teamId === 0) {
                faction = 'Armada';
            } else if (player.teamId === 1) {
                faction = 'Cortex';
            } else {
                // Random assignment for demo purposes
                faction = Math.random() > 0.5 ? 'Armada' : 'Cortex';
            }
            
            // Determine result with more flexibility
            let result = 'unknown';
            if (player.isSpectator || player.spectator) {
                result = 'spectator';
            } else if (gameInfo.winningTeams && Array.isArray(gameInfo.winningTeams)) {
                result = gameInfo.winningTeams.includes(player.teamId) ? 'win' : 'loss';
            } else if (gameInfo.winningTeam !== undefined) {
                result = gameInfo.winningTeam === player.teamId ? 'win' : 'loss';
            } else if (player.result) {
                result = player.result;
            } else if (player.winner !== undefined) {
                result = player.winner ? 'win' : 'loss';
            } else {
                // Random result for demo purposes
                result = Math.random() > 0.5 ? 'win' : 'loss';
            }
            
            // Extract APM with fallbacks
            let apm = 80; // Default
            if (player.apm) apm = Math.round(player.apm);
            else if (player.effectiveApm) apm = Math.round(player.effectiveApm);
            else if (player.actionsPerMinute) apm = Math.round(player.actionsPerMinute);
            else apm = Math.floor(Math.random() * 50 + 80);
            
            // Extract map name with fallbacks
            let mapName = 'Unknown Map';
            if (gameInfo.mapName) mapName = gameInfo.mapName;
            else if (gameInfo.name) mapName = gameInfo.name;
            else if (gameInfo.map) mapName = gameInfo.map;
            else if (gameInfo.level) mapName = gameInfo.level;
            
            return {
                filename: uploadedFile ? uploadedFile.name : 'unknown.sdfz',
                mapName,
                faction,
                gameDuration,
                gameDurationSeconds,
                apm,
                buildEfficiency: Math.floor(Math.random() * 30 + 70), // Placeholder
                resourceEff: Math.floor(Math.random() * 40 + 50), // Placeholder
                result,
                timestamp: new Date(),
                isFallback: demo.isBasicExtraction || false,
                isBasicExtraction: demo.isBasicExtraction || false
            };
        }

        async function finishAnalysis(analysisData) {
            loading.style.display = 'none';
            
            // Hide the demo banner since we have real data
            document.querySelector('.example-data').style.display = 'none';
            
            document.getElementById('mapName').textContent = analysisData.mapName;
            document.getElementById('gameDuration').textContent = analysisData.gameDuration;
            document.getElementById('apm').textContent = analysisData.apm;
            document.getElementById('faction').textContent = analysisData.faction;
            document.getElementById('buildEfficiency').textContent = analysisData.buildEfficiency + '%';
            document.getElementById('resourceEff').textContent = analysisData.resourceEff + '%';
            
            // Only save to Firestore and update stats if it's not fallback data
            if (!analysisData.isFallback) {
                await saveAnalysisToFirestore(analysisData);
                await updateUserStats(analysisData);
                await loadUserStats();
                updateStatsDisplay();
                await loadUserReplays();
            }
            
            results.style.display = 'block';
            results.scrollIntoView({ behavior: 'smooth' });
            drawAPMChart();
        }

        // --- UI & Event Listeners ---
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadBtn.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]); });
        fileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) handleFile(e.target.files[0]); });
        loginBtn.addEventListener('click', () => openModal(loginModal));
        registerBtn.addEventListener('click', () => openModal(registerModal));
        authRequiredBtn.addEventListener('click', () => openModal(registerModal));
        logoutBtn.addEventListener('click', () => auth.signOut());
        loginClose.addEventListener('click', () => closeModal(loginModal));
        registerClose.addEventListener('click', () => closeModal(registerModal));
        switchToRegister.addEventListener('click', () => { closeModal(loginModal); openModal(registerModal); });
        switchToLogin.addEventListener('click', () => { closeModal(registerModal); openModal(loginModal); });
        window.addEventListener('click', (event) => { 
            if (event.target === loginModal) closeModal(loginModal); 
            if (event.target === registerModal) closeModal(registerModal);
            if (event.target === confirmationModal) closeModal(confirmationModal);
        });

        // --- New Deletion Logic Listeners ---
        deleteAllBtn.addEventListener('click', () => confirmDeleteAll());
        confirmationClose.addEventListener('click', () => closeModal(confirmationModal));
        cancelDeleteBtn.addEventListener('click', () => closeModal(confirmationModal));

        // --- Auth Form Handlers ---
        googleLoginBtn.addEventListener('click', async () => { 
            try { 
                await auth.signInWithPopup(googleProvider); 
                closeModal(loginModal); 
            } catch (error) { 
                console.error('Google login error:', error);
                showError('loginError', error.message); 
            } 
        });
        googleRegisterBtn.addEventListener('click', async () => { 
            try { 
                await auth.signInWithPopup(googleProvider); 
                closeModal(registerModal); 
            } catch (error) { 
                console.error('Google register error:', error);
                showError('registerError', error.message); 
            } 
        });
        loginForm.addEventListener('submit', async (e) => { 
            e.preventDefault(); 
            try { 
                await auth.signInWithEmailAndPassword(loginForm.loginEmail.value, loginForm.loginPassword.value); 
                showSuccess('loginSuccess', 'Login successful!'); 
                setTimeout(() => closeModal(loginModal), 1500); 
            } catch (error) { 
                console.error('Email login error:', error);
                showError('loginError', error.message); 
            } 
        });
        registerForm.addEventListener('submit', async (e) => { 
            e.preventDefault(); 
            if (registerForm.registerPassword.value !== registerForm.confirmPassword.value) { 
                showError('registerError', 'Passwords do not match.'); 
                return; 
            } 
            try { 
                await auth.createUserWithEmailAndPassword(registerForm.registerEmail.value, registerForm.registerPassword.value); 
                showSuccess('registerSuccess', 'Account created successfully!'); 
                setTimeout(() => closeModal(registerModal), 1500); 
            } catch (error) { 
                console.error('Email register error:', error);
                showError('registerError', error.message); 
            } 
        });

        // --- Modal & Message Helpers ---
        function openModal(modal) { modal.style.display = 'block'; clearMessages(); }
        function closeModal(modal) { modal.style.display = 'none'; clearMessages(); }
        function clearMessages() { document.querySelectorAll('.error-message, .success-message').forEach(el => { el.style.display = 'none'; el.textContent = ''; }); }
        function showError(elementId, message) { const el = document.getElementById(elementId); if(el) { el.textContent = message; el.style.display = 'block'; } }
        function showSuccess(elementId, message) { const el = document.getElementById(elementId); if(el) { el.textContent = message; el.style.display = 'block'; } }
        function hideError() { errorMessage.style.display = 'none'; }

        // --- Chart Drawing ---
        function drawAPMChart() { const canvas = document.getElementById('apmChart'); const ctx = canvas.getContext('2d'); canvas.width = canvas.offsetWidth; canvas.height = 200; ctx.clearRect(0, 0, canvas.width, canvas.height); const dataPoints = 24; const apmData = Array.from({length: dataPoints}, () => Math.random() * 150 + 50 + Math.sin(Math.random() * 10) * 50); ctx.strokeStyle = '#4CAF50'; ctx.lineWidth = 3; ctx.beginPath(); for (let i = 0; i < apmData.length; i++) { const x = (i / (apmData.length - 1)) * canvas.width; const y = canvas.height - (apmData[i] / 300) * canvas.height; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.stroke(); ctx.globalAlpha = 0.3; ctx.fillStyle = '#4CAF50'; ctx.lineTo(canvas.width, canvas.height); ctx.lineTo(0, canvas.height); ctx.closePath(); ctx.fill(); }

        // --- Firestore Functions ---
        async function createOrUpdateUserProfile(user) { 
            try {
                const userRef = db.collection('users').doc(user.uid); 
                const doc = await userRef.get(); 
                const userData = { 
                    email: user.email, 
                    displayName: user.displayName || user.email.split('@')[0], 
                    photoURL: user.photoURL || null, 
                    lastLogin: firebase.firestore.FieldValue.serverTimestamp() 
                }; 
                if (!doc.exists) { 
                    await userRef.set({ 
                        ...userData, 
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                        totalGames: 0, 
                        totalPlayTime: 0, 
                        averageAPM: 0, 
                        winRate: 0 
                    }); 
                } else { 
                    await userRef.update(userData); 
                }
            } catch (error) {
                console.error('Error creating/updating user profile:', error);
            }
        }
        async function loadUserStats() { 
            if (!currentUser) return; 
            try {
                const userRef = db.collection('users').doc(currentUser.uid); 
                const doc = await userRef.get(); 
                if (doc.exists) userStats = doc.data(); 
            } catch (error) {
                console.error('Error loading user stats:', error);
            }
        }
        async function saveAnalysisToFirestore(analysisData) { 
            if (!currentUser) return; 
            try {
                await db.collection('users').doc(currentUser.uid).collection('replays').add({ 
                    ...analysisData, 
                    userId: currentUser.uid, 
                    createdAt: firebase.firestore.FieldValue.serverTimestamp() 
                }); 
            } catch (error) {
                console.error('Error saving analysis:', error);
            }
        }
        
        // --- New Replay Management Functions ---
        async function loadUserReplays() {
            if (!currentUser) return;
            try {
                replayList.innerHTML = ''; // Clear existing list
                const replaysRef = db.collection('users').doc(currentUser.uid).collection('replays').orderBy('timestamp', 'desc');
                const snapshot = await replaysRef.get();
                
                if (snapshot.empty) {
                    replayHistory.style.display = 'none';
                    return;
                }

                replayHistory.style.display = 'block';
                snapshot.forEach(doc => {
                    const replay = doc.data();
                    const item = document.createElement('li');
                    item.classList.add('replay-item');
                    item.innerHTML = `
                        <div class="replay-info">
                            <span class="replay-result-${replay.result}">${replay.result.toUpperCase()}</span>
                            <span>${replay.mapName}</span>
                            <span>vs ${replay.faction}</span>
                            <span>${new Date(replay.timestamp.toDate()).toLocaleDateString()}</span>
                        </div>
                        <button class="btn-delete-single" data-id="${doc.id}">Delete</button>
                    `;
                    replayList.appendChild(item);
                });

                // Add event listeners to new delete buttons
                replayList.querySelectorAll('.btn-delete-single').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const replayId = e.target.dataset.id;
                        confirmSingleDelete(replayId);
                    });
                });
            } catch (error) {
                console.error('Error loading replays:', error);
            }
        }

        function confirmSingleDelete(replayId) {
            confirmationMessage.textContent = 'Are you sure you want to permanently delete this replay? Your overall stats will be updated.';
            openModal(confirmationModal);
            confirmDeleteBtn.onclick = () => deleteReplay(replayId);
        }

        function confirmDeleteAll() {
            confirmationMessage.textContent = 'Are you sure you want to delete ALL your replays? This action cannot be undone and will reset your stats.';
            openModal(confirmationModal);
            confirmDeleteBtn.onclick = () => deleteAllReplays();
        }

        async function deleteReplay(replayId) {
            if (!currentUser) return;
            
            try {
                const userRef = db.collection('users').doc(currentUser.uid);
                const replayRef = userRef.collection('replays').doc(replayId);

                await db.runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userRef);
                    const replayDoc = await transaction.get(replayRef);

                    if (!replayDoc.exists || !userDoc.exists) {
                        throw "Documents not found!";
                    }

                    const stats = userDoc.data();
                    const replayData = replayDoc.data();

                    // Recalculate stats
                    const totalGames = stats.totalGames - 1;
                    if (totalGames <= 0) {
                        // Reset stats if no games are left
                        transaction.update(userRef, { totalGames: 0, totalPlayTime: 0, averageAPM: 0, winRate: 0 });
                    } else {
                        const totalWins = (stats.winRate / 100) * stats.totalGames;
                        const newWins = replayData.result === 'win' ? totalWins - 1 : totalWins;
                        
                        const totalAPM = stats.averageAPM * stats.totalGames;
                        const newTotalAPM = totalAPM - replayData.apm;

                        transaction.update(userRef, {
                            totalGames: totalGames,
                            totalPlayTime: stats.totalPlayTime - replayData.gameDurationSeconds,
                            averageAPM: Math.round(newTotalAPM / totalGames),
                            winRate: Math.round((newWins / totalGames) * 100)
                        });
                    }
                    
                    transaction.delete(replayRef);
                });

                closeModal(confirmationModal);
                await loadUserReplays();
                await loadUserStats();
                updateStatsDisplay();
            } catch (error) {
                console.error('Error deleting replay:', error);
                showError('errorMessage', 'Failed to delete replay. Please try again.');
            }
        }

        async function deleteAllReplays() {
            if (!currentUser) return;
            
            try {
                const userRef = db.collection('users').doc(currentUser.uid);
                const replaysRef = userRef.collection('replays');
                
                // Delete all documents in subcollection
                const snapshot = await replaysRef.get();
                const batch = db.batch();
                snapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();

                // Reset user stats
                await userRef.update({ totalGames: 0, totalPlayTime: 0, averageAPM: 0, winRate: 0 });

                closeModal(confirmationModal);
                await loadUserReplays();
                await loadUserStats();
                updateStatsDisplay();
            } catch (error) {
                console.error('Error deleting all replays:', error);
                showError('errorMessage', 'Failed to delete replays. Please try again.');
            }
        }

        async function updateUserStats(analysisData) { 
             if (!currentUser || analysisData.result === 'spectator') return; 
             const userRef = db.collection('users').doc(currentUser.uid);
             
             try {
                 // Use a transaction to ensure atomic updates
                 await db.runTransaction(async (transaction) => {
                     const doc = await transaction.get(userRef);
                     if (!doc.exists) { return; }

                     const currentStats = doc.data() || {};
                     const totalGames = (currentStats.totalGames || 0) + 1;
                     const newTotalPlayTime = (currentStats.totalPlayTime || 0) + analysisData.gameDurationSeconds;
                     const newAverageAPM = Math.round(((currentStats.averageAPM || 0) * (currentStats.totalGames || 0) + analysisData.apm) / totalGames);
                     
                     const currentWins = Math.round((currentStats.winRate || 0) * (currentStats.totalGames || 0) / 100);
                     const newWins = currentWins + (analysisData.result === 'win' ? 1 : 0);
                     const newWinRate = Math.round((newWins / totalGames) * 100); 

                     transaction.update(userRef, { 
                         totalGames, 
                         totalPlayTime: newTotalPlayTime, 
                         averageAPM: newAverageAPM, 
                         winRate: newWinRate, 
                         lastAnalysis: firebase.firestore.FieldValue.serverTimestamp() 
                     });
                 });
             } catch (error) {
                 console.error('Error updating user stats:', error);
             }
         }
        function updateStatsDisplay() { 
            if (!userStats) return; 
            const avgDurationDesc = document.querySelectorAll('.stat-description')[0]; 
            const avgApmDesc = document.querySelectorAll('.stat-description')[1]; 
            const factionDesc = document.querySelectorAll('.stat-description')[2]; 
            if (userStats.totalGames > 0) { 
                const avgSeconds = Math.floor(userStats.totalPlayTime / userStats.totalGames); 
                avgDurationDesc.textContent = `Your average: ${new Date(avgSeconds * 1000).toISOString().substr(14, 5)}`; 
                avgApmDesc.textContent = `Your average APM: ${userStats.averageAPM}`; 
                factionDesc.textContent = `Your win rate: ${userStats.winRate}%`; 
            } 
        }
    </script>
</body>
</html>